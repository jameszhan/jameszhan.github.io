<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>品码斋-Lambda演算之自然数</title>
    <meta name="description" content="资深码农，技术兴趣广泛，好读书，求甚解">
    <link rel="canonical" href="http://jameszhan.github.io/2014/09/10/lambda-church-number.html">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
	<script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="/assets/stylesheets/main.css">
</head>


<body>

<header class="navbar navbar-inverse navbar-fixed-top" role="banner" data-include="/assets/tpls/header.tpl"></header>

<div class="container">
    <div class="col-md-9">
    <div class="post">

        <header class="post-header">
            <h1 class="post-title">Lambda演算之自然数</h1>
            <p class="post-meta">
                2014年09月10日 •
                詹子知(James Zhan) •
                版权所有，转载须声明出处
            </p>
        </header>

        <article class="post-content">
            <p>λ演算（英语：lambda calculus，λ-calculus）是一套用于研究函数定义、函数应用和递归的形式系统。它由阿隆佐·邱奇和他的学生斯蒂芬·科尔·克莱尼在20世纪30年代引入。这种演算可以用来清晰地定义什么是一个可计算函数。</p>

<h2 id="λ演算规则">λ演算规则</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">  &lt;expression&gt; := &lt;name&gt; | &lt;function&gt; | &lt;application&gt;
  &lt;function&gt; := λ&lt;name&gt;.&lt;expression&gt;
  &lt;application&gt; := &lt;expression&gt;&lt;expression&gt;
</code></pre></div>
<h3 id="α--变换">α--变换</h3>

<p>α变换规则表达的是，被绑定变量的名称是不重要的。
α变换规则陈述的是，若v与w均为变量，E是一个lambda表达式，同时E[v/w]是指把表达式E中的所有的v的自由出现都替换成w，那么在w不是E中的一个自由出现，且如果w替换了v，w不会被E中的λ绑定的情况下，有
  λv.E == λw.E[v/w]
  例如：λx.(λx.x)x &lt;=&gt; λy.(λx.x)y</p>

<h3 id="β--规约">β--规约</h3>

<p>β规约规则表达的是函数作用的概念，它陈述了所有的E‘的自由出现在E[v/E&#39;]中仍然是自由的情况下，有 ((λv.E)E&#39;) == E[v/E&#39;] 成立。</p>

<h3 id="η--变换">η--变换</h3>

<p>η变换表达的是外延性的概念，在这里外延性指的是，两个函数对于所有的参数得到的结果一致，当且仅当它们是同一个函数，η变换可以令 λx.fx和f相互交换，只要x不是f中的自由出现。</p>

<h2 id="λ演算的应用">λ演算的应用</h2>

<p>在lambda演算系统中，一切事物都可以使用过程来描述。那么在函数式编程系统中，我们需要如何来描述一种类型呢？类型的本质在于它所定义的操作以及操作之间的关系和不变式。类型的实现关键在于满足类型规范的要求，而具体实现是可以变化的，使用者和测试用例都应该只依赖于类型规范而不依赖于具体实现。函数式的类型实现往往和类型规范是直接对应的，简单通用，但可能有性能问题，而命令式的类型实现往往会引入复杂的内部数据结构，但是其优点是高效。这两种实现并不是完全互斥的，有时候可以将二者相结合达到简单与高效的结合。</p>

<h3 id="形式定义">形式定义</h3>

<p>在lambda演算中有许多方式都可以定义自然数，但最常见的还是邱奇数，下面是它们的定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">  0 := λf.λx.x
  1 := λf.λx.f x
  2 := λf.λx.f (f x)
  3 := λf.λx.f (f (f x))
</code></pre></div>
<p>以此类推。直观地说，lambda演算中的数字n就是一个把函数f作为参数并以f的n次幂为返回值的函数。换句话说，邱奇整数是一个高阶函数 -- 以单一参数函数f为参数，返回另一个单一参数的函数。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">  SUCC  := λn.λf.λx.f (n f x)
  PLUS  := λm.λn.m SUCC n
  PLUS  := λm.λn.λf.λx.m f (n f x)
  MULT  := λm.λn.m (PLUS n) 0
  MULT  := λm.λn.λf.m (n f)
  PRED  := λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
  SUB   := λm.λn.n PRED m
  EXP   := λa.λn.n a
</code></pre></div>
<h3 id="clojure描述">Clojure描述</h3>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">zero</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">succ</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div>
<p>其实只要定义出zero和succ两个，我们就可以定义出所有的自然数。</p>

<p>你可以使用如下的方式给出zero和succ的定义。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">zero</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">succ</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span> <span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">f</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></div>
<p>是不是简洁了许多，但是不要被表面的简洁所迷惑，lambda演算基于的都是单参数的函数，这样函数可以很方便地得到一致性的处理。如果你使用Haskell来使用上述定义，这不会有什么问题，
因为其底层本身就是使用currying来描述多参函数的。然而Clojure却是严格区分函数的入参个数的，一旦你使用上述定义，自然数的许多操作将无法很容易地推论得到。事实上，使用currying，
我们可以很方便地使用单参函数模拟多参函数，但是反过来却不一定。有兴趣的朋友可以参考：<a href="https://raw.githubusercontent.com/jameszhan/rhea/master/codes/clojure/calculation/church-number.clj">多参描述自然数</a>.</p>

<p>我们可以根据代数变换的形式得出one, two, three的定义。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">one = (succ zero)
    = (fn [f] (fn [x] (f (((zero) f) x))))
    = (fn [f] (fn [x] (f ((fn [x] x) x))))
    = (fn [f] (fn [x] (f x)))

two = (succ one)
    = (fn [f] (fn [x] (f (((one) f) x))))
    = (fn [f] (fn [x] (f ((fn [x] (f x)) x))))
    = (fn [f] (fn [x] (f (f x))))
</code></pre></div>
<p>根据以上的推导过程，我们可以很容易地发现规律，我们可以很发现数字n的定义为</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">n</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nf">fn</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f...</span><span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></div>
<p>，其中(f...(f x))中有n个f。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">one</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">two</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">three</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div>
<p>根据定义，我们可以很容易地给出plus，mult，exp的定义，因为+，<em>，</em>*在自然数的操作里面是封闭的，所以其定义还是相当简洁和直观的。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">plus</span> <span class="p">[</span><span class="nv">m</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">((</span><span class="nf">m</span> <span class="nv">f</span><span class="p">)</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">mult</span> <span class="p">[</span><span class="nv">m</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nf">n</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">f</span><span class="p">)))))</span>
<span class="c1">;(defn mult [m n] (fn [f] (fn [x] ((n (m f)) x))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">exp</span> <span class="p">[</span><span class="nv">a</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">a</span><span class="p">)))</span>
<span class="c1">;(defn exp [a] (fn [n] (fn [f] (fn [x] (((n a) f) x)))))</span>
</code></pre></div>
<ol>
<li>plus可以理解为，对于初始值x，先对于其调用n次f，再对其运算后的结果再调用m次f，总共调用了(m + n)次f。</li>
<li>mult可以理解为，把(m f)展开n次，最终作用于x上，总共调用了(m * n)次f。</li>
<li>exp可以理解为，把a展开n次，得到(a (a...(a)))，当给定函数f和初始值x时，可以很容易得出其总共调用了(a ** n)次f。</li>
</ol>

<p>前驱和减法的定义不是很直观，毕竟其在自然数域里面操作并不封闭。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">pred</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
      <span class="p">(((</span><span class="nf">n</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">h</span><span class="p">]</span> <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">f</span><span class="p">)))))</span>
         <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">u</span><span class="p">]</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">u</span><span class="p">]</span> <span class="nv">u</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sub</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span><span class="p">]</span> <span class="p">((</span><span class="nf">m</span> <span class="nv">pred</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre></div>
<p>通过下面的函数，我们很容易把我们的邱奇数转换为我们熟悉的自然数表示。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">church-&gt;int</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">n</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)))</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div>
<h3 id="用例演示">用例演示</h3>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="nv">zero</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="nv">one</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="nv">two</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="nv">three</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;SUCC&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;PLUS&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">plus</span> <span class="nv">zero</span><span class="p">)</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">plus</span> <span class="nv">one</span><span class="p">)</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">plus</span> <span class="nv">one</span><span class="p">)</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">plus</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;MUL&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">zero</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">one</span><span class="p">)</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">one</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">three</span><span class="p">)</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">two</span><span class="p">)))</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;EXP&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">exp</span> <span class="nv">zero</span><span class="p">)</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">exp</span> <span class="nv">one</span><span class="p">)</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">exp</span> <span class="nv">two</span><span class="p">)</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">exp</span> <span class="nv">two</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">exp</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;PRED&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">pred</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">pred</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">pred</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">pred</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">three</span><span class="p">)))</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;SUB&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">sub</span> <span class="nv">zero</span><span class="p">)</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">sub</span> <span class="nv">two</span><span class="p">)</span> <span class="nv">two</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">sub</span> <span class="nv">two</span><span class="p">)</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">sub</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;int</span> <span class="p">((</span><span class="nf">sub</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">three</span><span class="p">))</span> <span class="nv">one</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>


<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nEVEN RULES&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">church-&gt;even</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">n</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;even</span> <span class="nv">zero</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;even</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;even</span> <span class="p">((</span><span class="nf">plus</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))</span> <span class="p">(</span><span class="nf">succ</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))))</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;even</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">18</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nEGATIVE NUMBER&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">church-&gt;neg</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">n</span> <span class="nv">dec</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;neg</span> <span class="nv">zero</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;neg</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))</span> <span class="mi">-1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;neg</span> <span class="p">((</span><span class="nf">plus</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))</span> <span class="p">(</span><span class="nf">succ</span> <span class="p">(</span><span class="nf">succ</span> <span class="nv">zero</span><span class="p">))))</span> <span class="mi">-3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">church-&gt;neg</span> <span class="p">((</span><span class="nf">mult</span> <span class="nv">three</span><span class="p">)</span> <span class="nv">three</span><span class="p">))</span> <span class="mi">-9</span><span class="p">))</span>
</code></pre></div>
<h3 id="参考">参考</h3>

<ol>
<li><a href="http://jameszhan.github.io/pdl/2014/09/18/lambda-y-combinator.html">Lambda演算之Y-Combinator的推导</a></li>
<li><a href="https://raw.githubusercontent.com/jameszhan/rhea/master/codes/clojure/calculation/lambda.clj">lambda演算示例代码</a></li>
</ol>

        </article>

        <div class="row-fluid">
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-folder-open"></i></li>
                
                
    
    <li class="tag"><a href="/categories/pdl.html">程序设计语言<span>7</span></a></li>
    

            </ul>
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-tags"></i></li>
                
                
    
    <li class="tag"><a href="/tags/lambda.html">Lambda<span>5</span></a></li>
    

    
    <li class="tag"><a href="/tags/fp.html">函数式编程<span>6</span></a></li>
    

    
    <li class="tag"><a href="/tags/clojure.html">Clojure<span>5</span></a></li>
    

    
    <li class="tag"><a href="/tags/pdl.html">程序设计语言<span>6</span></a></li>
    

            </ul>
        </div>

        <div class="row-fluid">
            <ul class="pagination pull-right">
                
                <li class="prev"><a href="/2014/09/01/ruby-metagramming.html" title="Ruby元编程技巧">&larr; 上一篇</a></li>
                
                <li><a href="http://jameszhan.github.io">Archive</a></li>
                
                <li class="next"><a href="/2014/09/16/code-styles.html" title="不同编程语言的代码风格比较">下一篇 &rarr;</a>
                </li>
                
            </ul>
        </div>
    </div>

    <div data-include="/assets/tpls/widgets/comments.tpl"></div>
</div>

<div class="col-md-3">
    <div data-include="/assets/tpls/widgets/tags.tpl"></div>
<div data-include="/assets/tpls/widgets/categories.tpl"></div>

</div>


</div>

<div class="container" data-include="/assets/tpls/footer.tpl"></div>

<div class="modal fade" id="globalModal" tabindex="-1" role="dialog" aria-labelledby="globalModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
        </div>
    </div>
</div>

<script type="text/javascript" src="/assets/javascripts/firing.js"></script>
<div class="analytics">
    <script type="text/javascript" src="/assets/javascripts/analytics.js"></script>
</div>
</body>
</html>