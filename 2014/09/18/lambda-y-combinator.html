<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>尽管扯淡-Lambda演算之Y-Combinator的推导</title>
    <meta name="description" content="资深码农，技术兴趣广泛，好读书，求甚解">
    <link rel="canonical" href="http://jameszhan.github.io/2014/09/18/lambda-y-combinator.html">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
	<script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="/assets/stylesheets/main.css">
</head>


<body>

<header class="navbar navbar-inverse navbar-fixed-top" role="banner" data-include="/assets/tpls/header.tpl"></header>

<div class="container">
    <div class="col-md-9">
    <div class="post">

        <header class="post-header">
            <h1 class="post-title">Lambda演算之Y-Combinator的推导</h1>
            <p class="post-meta">
                2014年09月18日 •
                詹子知(James Zhan) •
                版权所有，转载须声明出处
            </p>
        </header>

        <article class="post-content">
            <p>上一节中，我们讲到了如何使用λ演算来描述自然数，可以看出λ演算的表现力确实非常强大，然而遗憾的是，由于lambda演算中使用的都是匿名函数，所以它无法很直观地表述递归。
如果缺少了递归，λ演算的能力无疑会大打折扣。</p>

<p>所有基于λ演算的语言中，其实都是支持对过程进行命名的，那为什么这里我们还需要探讨匿名函数的递归呢？</p>

<ol>
<li>为了保持纯洁性，我们希望仅仅通过λ演算的规则本身来解决递归的问题。</li>
<li>部分语言对过程的命名必须等到该过程定义完成后才可以进行，这个时候我们必须找到一种方式使其能够很容易地获得递归的能力。</li>
</ol>

<h4 id="下面我们就是用factorial函数为原型，来看看如何使用lambda演算基本的规则，为其增加递归的能力。">下面我们就是用factorial函数为原型，来看看如何使用lambda演算基本的规则，为其增加递归的能力。</h4>

<p>传统定义方式，不过这个方式不符合我们的需求，因为它使用到了函数自身fact。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">fact</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">fact</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>几乎所有的问题解决过程都可以通过分层来解决，既然它不允许我们直接使用fact，那我们是不是可以直接把fact作为函数传入呢？</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact2</span> <span class="p">[</span><span class="nv">self</span> <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">fact2</span> <span class="nv">fact2</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>为了后续处理方便，我们先对该函数进行currying。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact3</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">((</span><span class="nf">self</span> <span class="nv">self</span><span class="p">)</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fact3</span> <span class="nv">fact3</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>((self self) (dec n)) 是不是有点丑陋，我们知道λ演算是数学家们搞出来的，他们对构造形式是有很严重的洁癖的。既然我们就是函数本身，为什么还需要(self, self)这样多此一举呢。
如果我们的定义能变成下面这样就比较完美了。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact3</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">self</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))))</span>
</code></pre></div>
<p>或者换成二元形式</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact3</span> <span class="p">[</span><span class="nv">f</span>, <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))</span>
</code></pre></div>
<p>这样也许更符合数学家们的口味，但是该函数是无法被直接执行的，这个使我们暂时假定的factorial的理想函数形式。为了构造这个理想函数形式，我们不妨把它变成(f (dec n))，下面我们试着把(self self)拎出来，用作参数f传入。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact4</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">fac-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))]</span>
            <span class="p">(</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fact4</span> <span class="nv">fact4</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>我们来看fac-gen的形式，其等价于</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fac-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))</span>
</code></pre></div>
<p>是不是和我们理想中的fact形式已经很接近了，当然其中有一个自由变量n，没关系，我们给他加个帽子。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact5</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">fac-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
              <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))))]</span>
      <span class="p">((</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fact5</span> <span class="nv">fact5</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>这次的fac-gen和我们的理想函数形式非常像了，换成二元就是</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fac-gen</span> <span class="p">[</span><span class="nv">f</span>, <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))))</span>
</code></pre></div>
<p>这正是我们找寻的理想形式。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact6</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">fac-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))))]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fact6</span> <span class="nv">fact6</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>让我们把fac-gen抽出来，作为一个单独的函数，它刚好就是我们要构造的factorial函数的理想形式，并给出fact7函数的定义。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fac-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">fact7</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fact7</span> <span class="nv">fact7</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>其实这个时候，fact7和factorial的计算过程已经没有什么关系了，换而言之，其实它可以更通用一些。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fact8</span> <span class="p">[</span><span class="nv">gen</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">self</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="c1">;; (fact8 fac-gen) = fact7</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">fact8</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">fact8</span> <span class="nv">fac-gen</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>fact8其实和factorial的计算过程没有任何关系，所以我们不妨给它换个名字</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">y</span> <span class="p">[</span><span class="nv">gen</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">self</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fac-gen</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>事实确是如此，该函数有一种神奇的能力，它不仅使可以计算factorial，它事实上可以计算所有形如factorial理想形式的函数递归。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fib-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">fib-gen</span><span class="p">))</span> <span class="mi">6</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">range-gen</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">()</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(((</span><span class="nf">y</span> <span class="nv">range-gen</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="nv">range-gen</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre></div>
<p>我们看下我们的调用，都是形如：(((y *-gen) (y *-gen)) n)的形式，还是相当丑陋的，我们不如精简下，简化其调用过程。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">y1</span> <span class="p">[</span><span class="nv">gen</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">g</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">gen</span> <span class="p">(</span><span class="nf">self</span> <span class="nv">self</span><span class="p">))</span> <span class="nv">n</span><span class="p">)))]</span>
    <span class="p">(</span><span class="nf">g</span> <span class="nv">g</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">y1</span> <span class="nv">range-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">y1</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">y1</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>去除letfn，把self使用f替换。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">Y</span> <span class="p">[</span><span class="nv">gen</span><span class="p">]</span>
  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">g</span><span class="p">))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">gen</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">f</span><span class="p">))</span> <span class="nv">n</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">Y</span> <span class="nv">range-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">Y</span> <span class="nv">fib-gen</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">Y</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>说了这么多，这个东西和Y Combinator又有什么关系？其实，我们最终得出的Y函数，其实就是我们所要苦苦找寻的Y Combinator函数，它具有性质Y(F) = F(Y(F)) = F(F(Y(F)))。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">Y</span> <span class="nv">fac-gen</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">fac-gen</span> <span class="p">(</span><span class="nf">Y</span> <span class="nv">fac-gen</span><span class="p">)))</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<h3 id="不动点组合子-y-combinator">不动点组合子(Y Combinator)</h3>

<p>函数f的不动点是一个值x使得f(x) = x。例如，0和1是函数f(x) = x**2的不动点，因为0**2 = 0而1**2 = 1。鉴于一阶函数（在简单值比如整数上的函数）的不动点
是个一阶值，高阶函数f的不动点是另一个函数g使得f(g) = g。那么，不动点算子是任何函数fix使得对于任何函数f都有 f(fix(f)) = fix(f).</p>

<p>在无类型lambda演算中众所周知的（可能是最简单的）不动点组合子叫做Y组合子。它是Haskell B. Curry发现的，定义为Y = λf.(λx.f (x x)) (λx.f (x x))用一个例子函数g来展开它，我们可以看到上面这个函数是怎么成为一个不动点组合子的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Y g = (λf.(λx. f (x x)) (λx. f (x x))) g
    = (λx. g (x x)) (λx. g (x x))            （λf的β-归约 - 应用主函数于g）
    = (λy. g (y y)) (λx. g (x x))            （α-转换 - 重命名约束变量）
    = g ((λx. g (x x)) (λx. g (x x)))        （λy的β-归约 - 应用左侧函数于右侧函数）
    = g (Y g)（Y的定义）
</code></pre></div>
<p>根据定义得出的函数如下，但是它毫无用武之地，当把参数应用到它之上时，它将会进入无穷递归。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defn y [f]
  ((fn [x] (f (x x)))
    (fn [x] (f (x x)))))
</code></pre></div>
<p>当该函数应用到f上时，当有</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">((fn [x] (f (x x))) (fn [x] (f (x x)))))
</code></pre></div>
<p>let g = (fn <a href="f%20x%20x">x</a>) 当有如下的执行过程</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(f (g g)) = (f ((fn [x] (f (x x))) g)) 
          = (f (f (g g)))
          ...
          = (f ... (f (g g)))
</code></pre></div>
<p>由于此处总是eager load，故此函数会进入无穷递归。</p>

<p>有没有办法让(f (x x))不展开呢? 可以，只需要加个lambda就可以使其变成lazy load。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">y1</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
     <span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
      <span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div>
<p>由于新增的lambda没有参数，故在clojure中我们调用的函数也不能有参数，但是已经可以实现递归了，下面的例子会进入无穷递归。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="nf">y1</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="ss">:hello</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span><span class="p">))))</span>
</code></pre></div>
<p>让我们给他加入参数，以便做支持更多的调用场景。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">y</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">n</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">y</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>上面的代码实现有明显重复的地方，根据DRY原则，我们稍稍对源代码进行下改造。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">Y</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">g</span><span class="p">))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">args</span><span class="p">]</span> <span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">args</span><span class="p">)))))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">((</span><span class="nf">Y</span> <span class="nv">fac-gen</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">120</span><span class="p">))</span>
</code></pre></div>
<p>我们根据Y Combinator也同时得出了Y函数的定义，和我们之前根据factorial推演得出的结果一模一样。</p>

<p>让我们来证明下，我们的Y确实是一个通用的不动点组合子。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Y = λf.(λx.λn.f (x x) n) (λx.λn.f (x x) n)
Y g n  = (λf.(λx.λn.f (x x) n) (λx.λn.f (x x) n)) g n
       = (λx.λn.g (x x) n) (λx.λn.g (x x) n) n
       = (λy.λm.g (y y) m) (λx.λn.g (x x) n) n
       = (λm.g ((λx.λn.g (x x) n) (λx.λn.g (x x) n)) m) n
       = (λm.g (Y g) m) n
       = g (Y g) n
</code></pre></div>
<h3 id="参考">参考</h3>

<ol>
<li><a href="http://jameszhan.github.io/2014/09/10/lambda-church-number.html">Lambda演算之自然数</a></li>
<li><a href="https://raw.githubusercontent.com/jameszhan/rhea/master/codes/clojure/calculation/deriving_y_combinator.clj">y-combinator演算示例代码</a></li>
</ol>

        </article>

        <div class="row-fluid">
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-folder-open"></i></li>
                
                
    
    <li class="tag"><a href="/categories/pdt.html">程序设计语言理论<span>7</span></a></li>
    

            </ul>
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-tags"></i></li>
                
                
    
    <li class="tag"><a href="/tags/lambda.html">Lambda<span>6</span></a></li>
    

    
    <li class="tag"><a href="/tags/fp.html">函数式编程<span>7</span></a></li>
    

    
    <li class="tag"><a href="/tags/clojure.html">Clojure<span>5</span></a></li>
    

    
    <li class="tag"><a href="/tags/lisp.html">Lisp<span>4</span></a></li>
    

    
    <li class="tag"><a href="/tags/pdt.html">程序设计语言理论<span>7</span></a></li>
    

            </ul>
        </div>

        <div class="row-fluid">
            <ul class="pagination pull-right">
                
                <li class="prev"><a href="/2014/09/16/code-styles.html" title="不同编程语言的代码风格比较">&larr; 上一篇</a></li>
                
                <li><a href="http://jameszhan.github.io">Archive</a></li>
                
                <li class="next"><a href="/2014/09/18/lambda-y-combinator-javascript.html" title="Lambda演算之Y-Combinator的推导(JS描述)">下一篇 &rarr;</a>
                </li>
                
            </ul>
        </div>
    </div>

    <!-- 多说评论框 start -->
<div class="ds-thread"
     data-thread-key="/2014/09/18/lambda-y-combinator.html"
     data-title="Lambda演算之Y-Combinator的推导"
     data-url="http://jameszhan.github.io/2014/09/18/lambda-y-combinator.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    var duoshuoQuery = {short_name:"jameszhan"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();

    $(document).on('click', '#ds-thread textarea[name=message]', function(){
        $('#ds-sync-checkbox').prop('checked', false);
    });
</script>
<!-- 多说公共JS代码 end -->



    <!--<div data-include="/assets/tpls/widgets/comments.tpl"></div>-->
</div>

<div class="col-md-3">
    <div data-include="/assets/tpls/widgets/tags.tpl"></div>
<div data-include="/assets/tpls/widgets/categories.tpl"></div>

</div>


</div>

<div class="container" data-include="/assets/tpls/footer.tpl"></div>

<div class="modal fade" id="globalModal" tabindex="-1" role="dialog" aria-labelledby="globalModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
        </div>
    </div>
</div>

<script type="text/javascript" src="/assets/javascripts/seajs/sea.js"></script>
<script type="text/javascript" src="/assets/javascripts/firing.js"></script>
<div class="analytics">
    <script type="text/javascript" src="/assets/javascripts/analytics.js"></script>
</div>
</body>
</html>