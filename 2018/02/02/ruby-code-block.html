<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>尽管扯淡-简单谈下 Ruby 中的代码块</title>
    <meta name="description" content="资深码农，程序设计语言控">
    <link rel="canonical" href="http://localhost:4000/2018/02/02/ruby-code-block.html">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="/assets/stylesheets/main.css">
</head>

<body>

<header class="navbar navbar-inverse navbar-fixed-top" role="banner" data-include="/assets/tpls/header.tpl"></header>
<div class="container">
    <div class="col-md-9">
    <div class="post">

        <header class="post-header">
            <h1 class="post-title">简单谈下 Ruby 中的代码块</h1>
            <p class="post-meta">
                2018年02月02日 • 詹子知(James Zhan)
            </p>
        </header>

        <article class="post-content">
            <h2 id="简介">简介</h2>

<p><strong>Block</strong> 是 <strong>Ruby</strong> 的一个独特特性，它本质上就是一组代码，通过它，可以很容易实现回调，或传递一组代码（远比C的函数指针灵活），以及实现迭代器。这是一个不可思议的功能强大的特性。</p>

<p>语法表现上，<strong>Block</strong> 是花括号或者<code class="highlighter-rouge">do</code>和<code class="highlighter-rouge">end</code>之间的一组代码，按照社区约定，我们可以通过以下两种方式来书写 <strong>Block</strong></p>

<ul>
  <li>多行，使用<code class="highlighter-rouge">do</code>和<code class="highlighter-rouge">end</code>作为开始和结束。</li>
  <li>单行，使用花括号</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">i</span>
<span class="k">end</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">each</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
3
1
2
3
</code></pre></div></div>

<h2 id="概念">概念</h2>

<p><strong>Block</strong> 相关的一些术语</p>

<ul>
  <li>闭包，<code class="highlighter-rouge">proc</code>，<code class="highlighter-rouge">lambda</code>, 函数，函数指针，匿名函数</li>
  <li>回调，<code class="highlighter-rouge">callable</code>，<code class="highlighter-rouge">functor</code>，<code class="highlighter-rouge">delegate</code></li>
</ul>

<p>我们介绍下其中的几个概念。</p>

<h4 id="闭包">闭包</h4>

<blockquote>
  <p>一个包含了自由变量的开放表达式，它和该自由变量的约束环境组合在一起后，实现了一种封闭的状态。 ──  Functional programming using standard ML, Prentice- Hall, 1987. 15</p>
</blockquote>

<p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的表达式（通常是函数）。这些被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 词法作用域(lexical scope)也叫静态作用域(static scope)。所谓的词法作用域其实是指作用域在词法解析阶段既确定了，不会改变，简单理解，就是代码块定义在哪里，就引用哪里的上下文环境。</p>

<p>闭包的数据结构可以定义为，包含一个函数定义 f 和它定义时所在的环境 (struct Closure (f env))</p>

<ul>
  <li>全局函数是一个有名字但不会捕获任何值的闭包。</li>
  <li>嵌套函数是一个有名字并可以捕获其封闭函数域内值得闭包。</li>
  <li>Lambda(闭包表达式)是一个利用轻量级语法所写的可以捕获其上下文中变量值的匿名闭包。</li>
</ul>

<h4 id="函数指针">函数指针</h4>

<p>函数指针在<code class="highlighter-rouge">C</code>语言中用的比较多，本质上，它就是一个内存地址，只不过指向的是一块可执行代码的首地址。和闭包相比，它并没有附带定义该函数的上下文信息，也不负责指针类型检查。</p>

<h4 id="functor">functor</h4>

<p>在<code class="highlighter-rouge">C++</code>中，<strong>functor</strong> 是行为类似函数的对象，可以拥有成员函数和成员变量，即 <strong>functor</strong> 拥有状态，其本质和闭包很接近，只是用起来比较繁琐。</p>

<h4 id="delegate">delegate</h4>

<p><code class="highlighter-rouge">C#</code>中的 <code class="highlighter-rouge">delegate</code> 类似于 <code class="highlighter-rouge">C</code> 或 <code class="highlighter-rouge">C++</code> 中的函数指针。使用 <code class="highlighter-rouge">delegate</code> 使程序员可以将方法引用封装在委托对象内。然后可以将该 <code class="highlighter-rouge">delegate</code> 对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，<code class="highlighter-rouge">delegate</code> 是面向对象、类型安全的，并且是安全的。</p>

<h2 id="可调用对象callable-object">可调用对象(<code class="highlighter-rouge">callable object</code>)</h2>

<p><strong>Ruby</strong> 中，可调用对象是可执行的代码片段，它们都有自己的作用域，可调用对象有以下几种方式：</p>

<ul>
  <li><strong>block</strong>，在定义它们的作用域中执行，它是闭包的一种。</li>
  <li><strong>proc</strong>，<code class="highlighter-rouge">Proc</code> 类的对象，和块一样，它们也在定义自身的作用域中执行，它也是闭包的一种。</li>
  <li><strong>lambda</strong>，也是 <code class="highlighter-rouge">Proc</code> 类的对象，和块一样，它们也在定义自身的作用域中执行，它和 <code class="highlighter-rouge">proc</code> 用法有细微的区别，也是闭包的一种。</li>
  <li><strong>method</strong>，绑定于对象，在所绑定对象的作用域中执行。</li>
</ul>

<h3 id="block"><code class="highlighter-rouge">block</code></h3>

<p><code class="highlighter-rouge">block</code> 闭包测试要麻烦一些，因为很多时候，很多时候都是在定义它的作用域中直接执行它，达不到逃逸的效果，为了验证 <code class="highlighter-rouge">block</code> 的闭包特性，我们需要先把 <code class="highlighter-rouge">block</code> 捕获起来，然后再调用。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">capture_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">block</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">clean_room</span>
  <span class="n">level_0</span> <span class="o">=</span> <span class="s2">"level0"</span>
  <span class="nb">lambda</span> <span class="k">do</span>
    <span class="n">level_1</span> <span class="o">=</span> <span class="s1">'level_1'</span>
    <span class="nb">proc</span> <span class="k">do</span>
      <span class="n">level_2</span> <span class="o">=</span> <span class="s1">'level_2'</span>
      <span class="n">capture_block</span> <span class="k">do</span>
        <span class="n">level_3</span> <span class="o">=</span> <span class="s1">'level_3'</span>
        <span class="nb">puts</span> <span class="s2">"block locals: </span><span class="si">#{</span><span class="nb">local_variables</span><span class="si">}</span><span class="s2">"</span>
        <span class="nb">self</span>
      <span class="k">end</span> 
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">callable</span> <span class="o">=</span> <span class="n">clean_room</span>
<span class="n">block0</span> <span class="o">=</span> <span class="n">callable</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">call</span>
<span class="n">block0</span><span class="p">.</span><span class="nf">call</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>block locals: [:level_3, :level_2, :level_1, :level_0]
</code></pre></div></div>

<p>上面的例子中其实有一个不严谨的地方，捕获块的时候，其实有一个隐式的转换。</p>

<p>上例中，<code class="highlighter-rouge">&amp;block</code> 对应的就是代码块：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span>
    <span class="n">level_3</span> <span class="o">=</span> <span class="s1">'level_3'</span>
    <span class="nb">puts</span> <span class="s2">"block locals: </span><span class="si">#{</span><span class="nb">local_variables</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span> 
</code></pre></div></div>

<p>当去掉 <code class="highlighter-rouge">&amp;</code> 直接访问 <code class="highlighter-rouge">block</code> 的时候，<strong>Ruby</strong> 会自动把 <code class="highlighter-rouge">&amp;block</code> 对应的代码块封装成一个 <code class="highlighter-rouge">Proc</code> 对象。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">block0</span><span class="p">.</span><span class="nf">class</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proc
</code></pre></div></div>

<p><code class="highlighter-rouge">&amp;block</code> 应该算是 <strong>Ruby</strong> 中的唯一一个不是对象的实体，它代表的是一组可以执行的代码，无法直接访问它，下面的代码会抛 <code class="highlighter-rouge">SyntaxError</code>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">proc0</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span> <span class="nb">puts</span> <span class="s2">"hello world"</span> <span class="p">}</span>
<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc0</span>
</code></pre></div></div>

<p>通过 <code class="highlighter-rouge">&amp;</code> 运算符，我们可以在 <code class="highlighter-rouge">&amp;block</code> 和 <code class="highlighter-rouge">Proc</code> 对象之间进行转换。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">proc0</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span> <span class="s2">"Hello World"</span> <span class="p">}</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="k">yield</span>
<span class="k">end</span>

<span class="n">run</span> <span class="o">&amp;</span><span class="n">proc0</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Hello World"
</code></pre></div></div>

<h3 id="proc">proc</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">clean_room</span>
  <span class="n">level_0</span> <span class="o">=</span> <span class="s2">"level0"</span>
  <span class="nb">lambda</span> <span class="k">do</span>
    <span class="n">level_1</span> <span class="o">=</span> <span class="s1">'level_1'</span>
    <span class="nb">proc</span> <span class="k">do</span>
      <span class="n">level_2</span> <span class="o">=</span> <span class="s1">'level_2'</span>
      <span class="nb">proc</span> <span class="k">do</span>
        <span class="n">level_3</span> <span class="o">=</span> <span class="s1">'level_3'</span>
        <span class="nb">puts</span> <span class="s2">"proc locals: </span><span class="si">#{</span><span class="nb">local_variables</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">end</span> 
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">callable</span> <span class="o">=</span> <span class="n">clean_room</span>
<span class="n">proc0</span> <span class="o">=</span> <span class="n">callable</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">call</span>

<span class="nb">puts</span> <span class="n">proc0</span><span class="p">.</span><span class="nf">call</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc locals: [:level_3, :level_2, :level_1, :level_0]
</code></pre></div></div>

<h3 id="lambda">lambda</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">clean_room</span>
  <span class="n">level_0</span> <span class="o">=</span> <span class="s2">"level0"</span>
  <span class="nb">lambda</span> <span class="k">do</span>
    <span class="n">level_1</span> <span class="o">=</span> <span class="s1">'level_1'</span>
    <span class="nb">proc</span> <span class="k">do</span>
      <span class="n">level_2</span> <span class="o">=</span> <span class="s1">'level_2'</span>
      <span class="nb">lambda</span> <span class="k">do</span>
        <span class="n">level_3</span> <span class="o">=</span> <span class="s1">'level_3'</span>
        <span class="nb">puts</span> <span class="s2">"lambda locals: </span><span class="si">#{</span><span class="nb">local_variables</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">end</span> 
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">callable</span> <span class="o">=</span> <span class="n">clean_room</span>
<span class="n">lambda0</span> <span class="o">=</span> <span class="n">callable</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">call</span>

<span class="nb">puts</span> <span class="n">lambda0</span><span class="p">.</span><span class="nf">call</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lambda locals: [:level_3, :level_2, :level_1, :level_0]
</code></pre></div></div>

<p><strong>ruby 1.9</strong> 之后，<code class="highlighter-rouge">lambda</code>还可以使用更简便的 <code class="highlighter-rouge">-&gt;</code> 记法。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-&gt;</span><span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Hello World!"</span> <span class="p">}.</span><span class="nf">call</span>
<span class="o">-&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">){</span> <span class="nb">puts</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World!
3
</code></pre></div></div>

<p><code class="highlighter-rouge">block</code>，<code class="highlighter-rouge">proc</code> 和 <code class="highlighter-rouge">lambda</code> 的区别，后面再重点介绍。</p>

<p>再来看一个例子：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_counter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="nb">lambda</span><span class="p">{</span> <span class="n">n</span> <span class="o">-=</span> <span class="mi">2</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">make_counter</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">make_counter</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c1 = 7, c2 = 4
c1 = 5, c2 = 2
c1 = 3, c2 = 0
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_counter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="nb">proc</span><span class="p">{</span> <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">make_counter</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">make_counter</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"c1 = </span><span class="si">#{</span><span class="n">c1</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">, c2 = </span><span class="si">#{</span><span class="n">c2</span><span class="p">.</span><span class="nf">call</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c1 = 8, c2 = 5
c1 = 7, c2 = 4
c1 = 6, c2 = 3
</code></pre></div></div>

<h2 id="yield">yield</h2>

<p>有别于其他语言，<strong>Ruby</strong> 中的 <code class="highlighter-rouge">yield</code> 是一种调用闭包的快捷方式。<strong>Ruby</strong> 有一种特殊的语法把匿名函数传递给一个方法，这种语法就是<code class="highlighter-rouge">block</code>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">twice</span>
   <span class="k">yield</span>
   <span class="k">yield</span>
<span class="k">end</span>

<span class="n">twice</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"hi!"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hi!
hi!
</code></pre></div></div>

<p><strong>Ruby</strong> 中对于所有方法，无论它的参数列表长什么样，它都可以在后面跟上一个可选的 <code class="highlighter-rouge">&amp;block</code>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">&amp;block</code> 严格来说不是一个参数，更像是一个声明，它指示一组执行代码的地址，如果直接访问 <code class="highlighter-rouge">block</code> 则会把这组代码封装在 <code class="highlighter-rouge">Proc</code> 对象当中，并把引用赋值给 <code class="highlighter-rouge">block</code>。这个块也可以使用 <code class="highlighter-rouge">yield</code> 来调用，这样可以不用关心代码块的名称。</p>

<p>如果显式地指定 <code class="highlighter-rouge">&amp;block</code> 参数，则 <code class="highlighter-rouge">yield</code> 调用的就是 <code class="highlighter-rouge">&amp;block</code> 传入的代码块。</p>

<p>直观理解，<code class="highlighter-rouge">yield</code> 可以理解是一个占位，指示 <code class="highlighter-rouge">&amp;block</code> 被调用的位置，并把 <code class="highlighter-rouge">&amp;block</code> 所需参数传递过去。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="k">end</span>

<span class="n">op</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">do</span><span class="o">|</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">|</span>
  <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
3
</code></pre></div></div>

<p>一个方法只能有一个 <code class="highlighter-rouge">&amp;block</code> 参数，<code class="highlighter-rouge">&amp;block</code> 只可以是最后一个方法参数。</p>

<p>以下的方法定义，都会抛 <code class="highlighter-rouge">SyntaxError</code>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">multi_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block2</span><span class="p">);</span> <span class="k">end</span>      <span class="c1"># 超过一个 block 参数</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">block_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span> <span class="k">end</span>           <span class="c1"># 出错，block 不是最后一个参数</span>
</code></pre></div></div>

<p>如果需要传入多个代码块到同一个方法，则其它对象需要使用 <strong>可调用对象</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ifthen</span><span class="p">(</span><span class="n">predict</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">predict</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">yield</span>
  <span class="k">else</span>
    <span class="nb">puts</span> <span class="s2">"Ignore"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">ifthen</span><span class="p">(</span><span class="nb">lambda</span><span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">|</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"lambda is executed"</span>
<span class="k">end</span>

<span class="n">ifthen</span><span class="p">(</span><span class="nb">proc</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">|</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"proc is executed"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
<span class="k">end</span>

<span class="n">ifthen</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:my_method</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"method is executed"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lambda is executed
proc is executed
method is executed
</code></pre></div></div>

<h2 id="block_given">block_given?</h2>

<p>任何方法在调用的时候后面都可以挂载一个<strong>代码块</strong>，尽管有时完全用不上这个<strong>代码块</strong>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">end</span>

<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"This code never called without yield!"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
</code></pre></div></div>

<p>如果你定义的方法想使用<strong>代码块</strong>做点事情，那么你需要使用 <code class="highlighter-rouge">yield</code> 关键字或者 <code class="highlighter-rouge">&amp;block</code>。</p>

<p>但是一旦方法中使用了 <code class="highlighter-rouge">yield</code> 关键字或者 <code class="highlighter-rouge">block.call</code>，则方法在调用的时候必须跟上一个代码块，哪怕这个代码块什么都不做。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="k">end</span>

<span class="n">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">){}</span>

<span class="k">begin</span>
  <span class="n">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">LocalJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"LocalJumpError: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LocalJumpError: no block given (yield)
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="k">end</span>

<span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">){}</span>

<span class="k">begin</span>
  <span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">NoMethodError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"NoMethodError: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NoMethodError: undefined method `call' for nil:NilClass
</code></pre></div></div>

<p>如下两种方法定义是等效的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">);</span> <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span> <span class="k">end</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span> <span class="k">end</span>
</code></pre></div></div>

<p>如果方法实现中，使用 <code class="highlighter-rouge">yield</code> 调用代码块的话，方法声明可以省掉 <code class="highlighter-rouge">&amp;block</code>。如果单看方法声明，使用方完全意识不到使用该方法还必须挂一个代码块，否则就会抛出 <code class="highlighter-rouge">LocalJumpError</code>。</p>

<p>基于以上原因， <strong>Ruby</strong> 提供了 <code class="highlighter-rouge">block_given?</code> 方法来判断方法后面是否挂了代码块，方便开发者在定义方法时能够考虑调用方忘记带上代码块的情形。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>

<span class="n">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="yield-vs-blockcall"><code class="highlighter-rouge">yield</code> vs <code class="highlighter-rouge">block.call</code></h2>

<p>理论上，<code class="highlighter-rouge">yield</code> 比 <code class="highlighter-rouge">block.call</code> 执行起来要高效一些，因为在调用之前需要先将 <code class="highlighter-rouge">&amp;block</code> 转换成 <code class="highlighter-rouge">Proc</code> 对象。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>

<span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">){</span> <span class="nb">puts</span> <span class="s2">"Hello World"</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World
</code></pre></div></div>

<p>上面的代码，如果把过程展开，等价于：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">block_given?</span>
    <span class="n">blk</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="o">&amp;</span><span class="n">block</span> 
    <span class="n">blk</span><span class="p">.</span><span class="nf">call</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">){</span> <span class="nb">puts</span> <span class="s2">"Hello World"</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World
</code></pre></div></div>

<p>另外，使用匿名代码块的写法也要简洁一些，不过显式的代码块要灵活一些，你可以显式把 <code class="highlighter-rouge">block</code> 传递给其他被调用方法。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ls_files</span>
  <span class="no">Dir</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s2">"*.ipynb"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">ipynb</span><span class="o">|</span>
    <span class="k">yield</span> <span class="n">ipynb</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">ls_files</span><span class="p">{</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">file</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>03.02-conditional-statements.ipynb
03.04-iterators.ipynb
03.10-ruby-meta-programming.ipynb
03.11-ruby-style-guide.ipynb
03.03-loop-statements.ipynb
03.07-scope.ipynb
03.01-assignment-statements.ipynb
03.05-functions.ipynb
03.06-blocks.ipynb
03.09-exceptions.ipynb
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ls_files2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Dir</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s2">"*.ipynb"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">ls_files2</span><span class="p">{</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">file</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>03.02-conditional-statements.ipynb
03.04-iterators.ipynb
03.10-ruby-meta-programming.ipynb
03.11-ruby-style-guide.ipynb
03.03-loop-statements.ipynb
03.07-scope.ipynb
03.01-assignment-statements.ipynb
03.05-functions.ipynb
03.06-blocks.ipynb
03.09-exceptions.ipynb
</code></pre></div></div>

<h2 id="symbolto_proc"><code class="highlighter-rouge">Symbol#to_proc</code></h2>

<p>这种有点诡异的法术在Ruby程序员中很流行，请看下面的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'bob'</span> <span class="p">,</span> <span class="s1">'bill'</span> <span class="p">,</span> <span class="s1">'heather'</span> <span class="p">]</span>
<span class="n">names</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">capitalize</span> <span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>["Bob", "Bill", "Heather"]
</code></pre></div></div>

<p>更简洁的写法</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'bob'</span> <span class="p">,</span> <span class="s1">'bill'</span> <span class="p">,</span> <span class="s1">'heather'</span> <span class="p">]</span>
<span class="n">names</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:capitalize</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>["Bob", "Bill", "Heather"]
</code></pre></div></div>

<p>当<code class="highlighter-rouge">&amp;</code>操作符作用于一个对象时，它会调用该对象的<code class="highlighter-rouge">to_proc</code>方法，先将其转化为一个<code class="highlighter-rouge">proc</code>对象，再把他转换为对应的代码块。</p>

<p><code class="highlighter-rouge">:capitalize</code> 是 <code class="highlighter-rouge">Symbol</code> 类的实例, <code class="highlighter-rouge">Symbol</code> 中的 <code class="highlighter-rouge">to_proc</code> 方法的实现类似于：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Symbol</span>
    <span class="k">def</span> <span class="nf">to_proc</span>
        <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面的代码等价于：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'bob'</span> <span class="p">,</span> <span class="s1">'bill'</span> <span class="p">,</span> <span class="s1">'heather'</span> <span class="p">]</span>
<span class="n">block</span> <span class="o">=</span> <span class="ss">:capitalize</span><span class="p">.</span><span class="nf">to_proc</span>
<span class="n">names</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>["Bob", "Bill", "Heather"]
</code></pre></div></div>

<h2 id="proc-vs-lamba"><code class="highlighter-rouge">proc</code> vs. <code class="highlighter-rouge">lamba</code></h2>

<p><code class="highlighter-rouge">proc</code> 和 <code class="highlighter-rouge">lambda</code> 之间的差异可能是 <strong>Ruby</strong> 中最令人费解的特性。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">callable</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">callable</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span> <span class="s2">"Proc called"</span> <span class="p">}</span>
<span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span> <span class="s2">"Lambda called"</span> <span class="p">}</span>

<span class="n">run</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span>
<span class="n">run</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proc called
Lambda called
</code></pre></div></div>

<p>在 <strong>Ruby</strong> 中，最后一行的 <code class="highlighter-rouge">return</code> 关键字是经常可以省略的，但是在 <code class="highlighter-rouge">proc</code> 和 <code class="highlighter-rouge">lambda</code> 当中，加上 <code class="highlighter-rouge">return</code> 关键字后，他们的行为是不一致的。</p>

<p>在 <code class="highlighter-rouge">lambda</code> 中，<code class="highlighter-rouge">return</code> 仅仅表示从这个 <code class="highlighter-rouge">lambda</code> 中返回，在 <code class="highlighter-rouge">proc</code> 当中，它不是从 <code class="highlighter-rouge">proc</code> 中返回，而是从定义 <code class="highlighter-rouge">proc</code> 的上下文中返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">callable</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"before callable called"</span>
  <span class="nb">puts</span> <span class="n">callable</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">puts</span> <span class="s2">"after callable called"</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:run
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span> <span class="k">return</span> <span class="s2">"Lambda called"</span> <span class="p">}</span>
<span class="n">run</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>before callable called
Lambda called
after callable called
</code></pre></div></div>

<p><code class="highlighter-rouge">proc</code> 的行为比较诡异，更好的设计应该是从 <code class="highlighter-rouge">run</code> 方法返回，<code class="highlighter-rouge">lambda</code> 更像是一个方法调用，而 <code class="highlighter-rouge">proc</code> 则相当于把代码块插入到调用的位置去执行，上面的执行代码等价于：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">binding</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"before callable called"</span>
  <span class="nb">puts</span> <span class="nb">eval</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">binding</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"after callable called"</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span> <span class="k">return</span> <span class="s2">"Proc called"</span> <span class="p">}</span>

<span class="k">begin</span> 
  <span class="n">run</span><span class="p">(</span><span class="s1">'return "Proc called"'</span><span class="p">,</span> <span class="nb">p</span><span class="p">.</span><span class="nf">binding</span><span class="p">)</span>  
<span class="k">rescue</span> <span class="no">LocalJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"proc executed error </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>before callable called
proc executed error unexpected return.
</code></pre></div></div>

<p>当执行到 <code class="highlighter-rouge">return "Proc called"</code> 的时候，原本应该返回到 <code class="highlighter-rouge">run</code> 的返回地址，但是因为 <code class="highlighter-rouge">proc</code> 记录的确是定义它的 <code class="highlighter-rouge">main</code> 返回地址，因此报错，如果不考虑绑定，更直观的展开如下。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">()</span>
  <span class="nb">puts</span> <span class="s2">"before callable called"</span>
  <span class="nb">puts</span> <span class="k">return</span> <span class="s2">"Proc called"</span>
  <span class="nb">puts</span> <span class="s2">"after callable called"</span>
<span class="k">end</span>

<span class="n">run</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">callable</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"before callable called"</span>
  <span class="n">callable</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">puts</span> <span class="s2">"after callable called"</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span> <span class="k">return</span> <span class="s2">"proc called"</span> <span class="p">}</span>
  
<span class="k">begin</span> 
  <span class="n">run</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span>  
<span class="k">rescue</span> <span class="no">LocalJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"proc executed error </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>before callable called
proc executed error unexpected return.
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span> 
  <span class="k">return</span> <span class="s2">"Proc called"</span>
<span class="k">rescue</span> <span class="no">LocalJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"proc executed error </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc executed error unexpected return.
</code></pre></div></div>

<p>不过只要我们弄明白了这个坑点，倒是可以用来做一些有意思的事情。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">count_down_to</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">sentry</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span><span class="o">|</span><span class="n">n</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>
      <span class="k">return</span> <span class="s2">"count down finished by sentry!"</span>
    <span class="k">end</span>
  <span class="k">end</span>
  
  <span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">sentry</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>
  
  <span class="mi">10</span><span class="p">.</span><span class="nf">downto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span><span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="nb">print</span> <span class="n">i</span><span class="p">,</span> <span class="s1">', '</span>
    <span class="nb">lambda</span><span class="p">{</span> <span class="n">l</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}.</span><span class="nf">call</span>
  <span class="k">end</span>
  
  <span class="k">return</span> <span class="s2">"count down finish!"</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">count_down_to</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">count_down_to</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10, 9, 8, 7, 6, 5, 4, 3, count down finish!
10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, count down finished by sentry!
</code></pre></div></div>

<p><code class="highlighter-rouge">proc</code> 和 <code class="highlighter-rouge">lambda</code> 还有点重要的区别来自他们检查参数的方式，<code class="highlighter-rouge">lambda</code> 总是检查传入的参数数量，如果和定义的不匹配，会抛出一个 <code class="highlighter-rouge">ArgumentError</code>。而 <code class="highlighter-rouge">proc</code> 则会把传递进来的参数调整为自己期望的参数形式，如果参数比期望的要多，<code class="highlighter-rouge">proc</code> 会忽略多余的参数，如果参数数量不足，那么对未指定的参数，proc会赋一个 <code class="highlighter-rouge">nil</code> 值。</p>

<p>我们再来看 <code class="highlighter-rouge">block</code>，它的行为更像 <code class="highlighter-rouge">proc</code>，所以一般我们最好不要在 <code class="highlighter-rouge">block</code> 块中使用 <code class="highlighter-rouge">return</code>，除非你明确知道自己在干什么。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">()</span>
  <span class="nb">puts</span> <span class="s2">"before callable called"</span>
  <span class="nb">puts</span> <span class="k">yield</span>
  <span class="nb">puts</span> <span class="s2">"after callable called"</span>
<span class="k">end</span>

<span class="n">run</span><span class="p">{</span> <span class="s2">"Block called"</span> <span class="p">}</span>
<span class="n">run</span><span class="p">{</span> <span class="o">|</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">|</span> <span class="s2">"Do not check the arguments"</span> <span class="p">}</span>

<span class="k">begin</span> 
  <span class="n">run</span><span class="p">{</span> <span class="k">return</span> <span class="s2">"Block called"</span> <span class="p">}</span>
<span class="k">rescue</span> <span class="no">LocalJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">puts</span> <span class="s2">"block executed error </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>before callable called
Block called
after callable called
before callable called
Do not check the arguments
after callable called
before callable called
block executed error unexpected return.
</code></pre></div></div>

<p>整体而言，<code class="highlighter-rouge">lambda</code> 更直观，也更像一个方法，它不仅对参数数量要求严格，而且在调用 <code class="highlighter-rouge">return</code> 时，只在 <code class="highlighter-rouge">lambda</code> 的代码块返回。基于这些原因，如没有使用到某些 <code class="highlighter-rouge">proc</code> 的特殊功能，应该总是优先选择使用 <code class="highlighter-rouge">lambda</code>。</p>

<p>更多 <strong>Ruby</strong> 资料整理，移步<a href="https://github.com/jameszhan/notes-ruby">Ruby 编程手札</a></p>

        </article>

        <div class="row-fluid">
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-folder-open"></i></li>
                 
    
    <li class="tag"><a href="/categories/ruby.html">Ruby<span>3</span></a></li>
    

            </ul>
            <ul class="list-inline">
                <li><i class="glyphicon glyphicon-tags"></i></li>
                 
    
    <li class="tag"><a href="/tags/ruby.html">Ruby<span>7</span></a></li>
    

    
    <li class="tag"><a href="/tags/metaprogramming.html">元编程<span>4</span></a></li>
    

    
    <li class="tag"><a href="/tags/dsl.html">DSL<span>4</span></a></li>
    

    
    <li class="tag"><a href="/tags/pdt.html">程序设计语言理论<span>12</span></a></li>
    

            </ul>
        </div>

        <div class="row-fluid">
            <ul class="pagination pull-right">
                
                <li class="prev"><a href="/2017/10/22/gradient-descent-derivation.html" title="梯度下降从放弃到入门">&larr; 上一篇</a></li>
                
                <li><a href="http://localhost:4000">Archive</a></li>
                
                <li class="next"><a href="/2018/02/03/ruby-variable-scope.html" title="理解 Ruby 中的变量作用域">下一篇 &rarr;</a>
                </li>
                
            </ul>
        </div>
    </div>

    
</div>

<div class="col-md-3">
    <div data-include="/assets/tpls/widgets/tags.tpl"></div>
<div data-include="/assets/tpls/widgets/categories.tpl"></div>

</div>


</div>

<div class="container" data-include="/assets/tpls/footer.tpl"></div>

<div class="modal fade" id="globalModal" tabindex="-1" role="dialog" aria-labelledby="globalModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
        </div>
    </div>
</div>

<script type="text/javascript" src="/assets/javascripts/seajs/sea.js"></script>
<script type="text/javascript" src="/assets/javascripts/firing.js"></script>
<div class="analytics">
    <script type="text/javascript" src="/assets/javascripts/analytics.js"></script>
</div>
</body>
</html>